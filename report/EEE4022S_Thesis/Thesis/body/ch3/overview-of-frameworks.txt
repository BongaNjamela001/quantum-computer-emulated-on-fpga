\section{Overview of Previous Frameworks for Quantum Computer Simulations on Hardware Accelerators}

In classical computing, parallelism is characterised by the number of threads or processing cores in specialised devices such as CPUs and GPUs that can execute fundamental units of computational work concurrently. In quantum computing, calculations can be performed in parallel by unitary transformations acting on entangled quantum states \cite{markidis2024quantum}. The extent of decoherence can be limited by entanglement purification and distillation which can be achieved extracting a subset of states of high entanglement and high purity large set of mixed states that are less correlated or entangled \cite{marinescu2005promise}. Unlike symmetric multiprocessing (SMP) and heterogeneous computer-based parallelism, the fine-granularity of FPGAs allows for the independent control of single bit processing elements, making FPGAs intrinsically parallel multiple instruction and multiple data (MIMD) devices \cite{cieszewski2013review}. Additionally, since FPGAs offer bit-level parallelism, they can provide improved performance in simulations of the computations involved in quantum computing algorithms that execute unitary operations on quantum states represented by dense matrices. 

The large number of cores and memory on GPUs also makes them suitable for emulating resource intensive quantum computations. Stavros Efthymiou et al. presented \texttt{Qibo} as a new open-source software for fast evaluation of quantum circuit and adiabatic evolution taking advantage of the multiple cores on a GPU \cite{efthymiou2021qibo}. The \texttt{Qibo} software framework uses TensorFlow primitives because of the simple mechanisms for writing Python code and custom operators, together with job scheduling for multi-GPU synchronisation \cite{efthymiou2021qibo}. The \texttt{Qibo} stack provides several features for simulating quantum circuits for research purposes. This stack includes an interface for users with a model definition and that initialises execution of algorithms. Lower levels of the stack also include the TensorFlow and abstraction layer backends as illustrated in figure \ref{fig:qibo-framework-stack} \cite{efthymiou2021qibo}. 

\begin{figure}[!ht]
	\centering
	\includegraphics[width=0.38\linewidth]{body/ch3/figs/qibo-framework}
	\caption[Qibo software.]{Qibo framework for simulating quantum gates and circuits on hardware accelerators such as GPUs.}
	\label{fig:qibo-framework-stack}
\end{figure}

To develop and implement quantum algorithms while compensating for the costs of achieving stable quantum systems, Khalid et al. describe the emulation of quantum circuits in FPGAs which can map the parallel tasks more efficiently than software simulations \cite{Khalid2004}. In their approach, quantum circuits are modelled using VHDL and synthesized in hardware to achieve the performance that is required for practical applications. 

Khalid et al. implement a qubit by storing values of the state amplitudes $\alpha$ and $\beta$ for a state vector with the standard basis set $\{\ket{0}, \ket{1}\}$. The amplitudes were processed using a fixed point scheme. The reason for opting for a fixed point scheme instead of using floating-point representations was because of $\alpha$ and $\beta$ having a decimal part of 0 or 1 only \cite{Khalid2004}. Their approach to quantum gates was to introduce an input error $\delta$ that is propagated and augmented with discretisation error $\epsilon$ in the coefficients of the quantum gate's unitary matrix. An expanded error model includes multiple errors that are added linearly to the qubit transformation, as illustrated in figure \ref{fig:khalidErrorModel}.

\begin{figure}[!ht]
	\centering
	\includegraphics[width=0.98\linewidth]{body/ch3/figs/khalid-error-model}
	\caption[Expanded error model includes gate precision errors, input errors and computation errors.]{Quantum gate model accounting for input errors, gate imprecision errors and computation errors that affect the output of a quantum algorithm.}
	\label{fig:khalidErrorModel}
\end{figure}

These errors arise when performing quantum measurements according the Heisenberg's Uncertainty Principle, and affect the probability of the qubit being in the $\ket{0}$ or $\ket{1}$ state \cite{Khalid2004}. Using the Bloch sphere representation to illustrate the state of the qubit where the desired state vector is $(\alpha, \beta)^T$ and the actual measured state vector is $(\alpha + \alpha_\epsilon, \beta + \beta_\epsilon)$, Khalid et al. define the absolute error in the measurement as the distance $E$ between the actual state values and the measured state values, as shown in figure \ref{fig:absoluteError}. 

Khalid et al. considered errors when mapping quantum gate transformations to VHDL code and showed that an $n$-qubit gate is represented by a $2^n \times 2^n$ matrix \cite{Khalid2004}. For controlled gates, variables were passed as a parameter to a code generating script which automated the construction of an arbitrary size quantum gates \cite{Khalid2004}. Immediate registers, called \textit{quantum state registers} (QSRs), were used to hold the qubit states after each gate in a quantum circuit, as depicted in figure \ref{fig:khalid-emulated-overview}. 

\begin{figure}[!ht]
	\centering
	\includegraphics[width=0.80\linewidth]{body/ch3/figs/khalid-emulated-overview}
	\caption[Proposed emulated circuit overview.]{Emulated quantum circuit uses quantum state registers to hold qubit values at the output of each quantum gate in a quantum circuit.}
	\label{fig:khalid-emulated-overview}
\end{figure}

Since time flows from left to right in the quantum circuit diagram, each quantum register is equivalent to a representation of the state of the entire 3-qubit quantum system \cite{Khalid2004}. While describing the mathematical simulation of quantum systems of $n$-qubits, Radtke and Fritzsche define the notion of a $n$-qubit quantum register as the basic 'storage' of the behaviour of $n$-qubit quantum systems \cite{radtke2005simulation}. Radtke and Fritszche presented the \textit{Feynman} program, in the multi-paradigm programming language \texttt{MAPLE}, for simulating a general $n$-qubit quantum system in the sense that the unitary transformations of quantum registers could be in a pure state or could be quantum operators (gates) applied to coupled quantum registers. These $n$-qubit quantum registers were represented as basic data structures using the auxiliary functions \texttt{qregister()} either in terms of its $2^n$-dimensional state or the $2^n \times 2^n$ density matrix. Based on this definition of quantum registers, Radtke and Fritszche's Feynman program also included a \texttt{Feynman\_quantum\_operator()} procedure with predefined matrix representations quantum gate operations that could be selected using different argument options. For example, the single-qubit quantum operator gate $X$ gate was accessible in the program by the command \texttt{Feynman\_quantum\_operator()} by using the argument options "not", "sigma\_x" or "X". Quantum operations that lead to the rotation of a quantum state by an angle $\theta$, such as the $R_x$, $R_y$ and $R_z$ gates were accessed by using the angle as an function parameter. For modelling multiple-qubit gates, such as the two-qubit \texttt{CNOT} gate, Radtke and Fritszche introduced \textit{distributed gates} to handle the case where a $n$-qubit quantum register is transformed by a $k$-qubit quantum gate such that $k\leq n$. Using distributed gates, the $2^k$ matrix elements of the $k$-qubit quantum gate need to be mapped efficiently over the $2^n \times 2^n$ matrix which acts on the complete $n$-qubit register \cite{radtke2005simulation}. 

Crucially, the Radtke and Fritszche used the \texttt{Feynman\_trace()} procedure for calculating the expectation value (or normalised probability) of a matrix operator with respect to a give quantum state whose behaviour is represented in the $n$-qubit quantum register \cite{radtke2005simulation}. By employing this approach of using set of functions to manipulate $n$-qubit quantum registers, Radtke and Fitszche successfully showed that the normalised probability of measuring a quantum state can be calculated from the trace of the density matrix of the quantum register \cite{radtke2005simulation}. This however, does not apply to entangled systems, since the reduced density operators of the subsystems cannot be measured easily and requires one to carry out the partial trace operation explicitly \cite{radtke2005simulation}. In an example using entangled product Bell State represented by a matrix $\rho_{AB}$, Radtke and Fitszche use quantum registers to represent the mixed $n$-qubit system by taking the trace over the squared reduced density matrix $\rho_A$ and $\rho_B$. The result were useful in showing whether a composite system is in a mixed or pure state\cite{radtke2005simulation}. 
 
